## 1. TCP/IP 프로토콜 [스택] → 차곡차곡

### 1-1. TCP/IP 프로토콜 스택이란?

- 인터넷 기반의 데이터 송수신을 목적으로 설계된 스택
- `큰 문제를 작게 나눠서 계층화` 한 결과
- 데이터 송수신의 과정을 네 개의 영역으로 계층화 한 결과
- 각 스택 별 영역을 전문화하고 `표준화` 함
- `7계층`으로 세분화가 되며, 4계층으로도 표현함

![1](https://github.com/user-attachments/assets/9c000bfa-74a6-4ff4-97a3-4c6ebf0dbc48)

- 전송 계층 - TCP 계층과 UDP 계층으로 나뉨
- 라우터 - IP 계층
    - 데이터를 목적지까지 전송하는데 사용되는 알고리즘
    - A사의 라우터를 쓰나, B사의 라우터를 쓰나 같음
    - why? 표준화되어 있기 때문!
    - 표준화가 그만큼 중요하다
- 물리적인 연결 - LINK
    - 이렇게 이렇게 라우터들을 연결하자

![2](https://github.com/user-attachments/assets/43a84f20-4106-4bdc-8c04-b9f9b0bdb4cc)

## 2. LINK & IP 계층

### 2-1. LINK 계층의 기능 및 역할

- `물리적인 영역`의 표준화 결과
- LAN, WAN, MAN과 같은 물리적인 네트워크 표준 관련 프로토콜이 정의된 영역
- 아래의 그림과 같은 물리적인 연결의 표준이 된다

![3](https://github.com/user-attachments/assets/9d78bc07-a718-4f03-b900-b1a3e4c97868)

### 2-2. IP 계층의 기능 및 역할

- IP는 Internet protocol을 의미함
- 경로의 설정과 관련이 있는 프로토콜
- 물리적인 계층 위에서, 어디로 보낼까? → 알고리즘 → IP 계층 표준의 결과이다

## 3. TCP/UDP 계층

### 3-1. TCP/UDP 계층의 기능 및 역할

- 실제 데이터의 송수신과 관련 있는 계층
- 그래서 전송(Transport) 계층이라고도 함
- TCP는 데이터의 전송을 보장하는 프로토콜(신뢰성 있는 프로토콜), UDP는 보장하지 않는 프로토콜
- TCP는 신뢰성을 보장하기 때문에 UDP에 비해 복잡한 프로토콜이다

![4](https://github.com/user-attachments/assets/2b8ed91a-463b-465e-a82e-af8fca9f248e)

## 4. APPLICATION 계층

### 4-1. 프로그래머에 의해서 완성되는 APPLICATION 계층

- 응용프로그램의 프로토콜을 구성하는 계층
- 소켓을 기반으로 완성하는 프로토콜을 의미함
- 소켓을 생성하면, 앞서 보인 LINK, IP, TCP/UDP 계층에 대한 내용은 감춰진다
- 그러니 응용 프로그래머는 APPLICATION 계층의 완성에 집중하게 된다

---

## 5. TCP 서버

### 5-1. TCP 서버의 기본적인 함수 호출 순서

<img width="357" alt="5" src="https://github.com/user-attachments/assets/dea50ba7-e37e-411e-b3a0-3a26981f7793">

- bind함수까지 호출이 되면 주소가 할당된 소켓을 얻게 됨
- listen 함수의 호출을 통해서 연결요청이 가능한 상태가 되어야 함

### 5-2. 연결 요청 대기 상태로의 진입

```c
#include <sys/type.h>

int listen(int sock, int backlog);
// 성공 시 0, 실패 시 -1 반환
```

| sock | 연결 요청 대기상태에 두고자 하는 소켓의 파일 디스크립터 전달, 이 함수의 인자로 전달된 디스크립터의 소켓이 서버 소켓(리스닝 소켓)이 된다 |
| --- | --- |
| backlog | 연결요청 대기 큐(Queue)의 크기 정보 전달, 5가 전달되면 큐의 크기가 5가 되어 클라이언트의 연결 요청을 5개까지 대기시킬 수 있다 |

<img width="549" alt="6" src="https://github.com/user-attachments/assets/96b463a5-746f-43b8-9116-8819ffd226c2">

- 연결 요청도 일종의 데이터 전송이다
- 따라서 연결 요청을 받아들이기 위해서는 하나의 소켓이 필요하다
- 이 소켓을 가리켜 서버 소켓 또는 리스닝 소켓이라 한다
- listen 함수의 호출은 소켓을 리스닝 소켓이 되게 한다
- `서버 소켓은 단순히 요청들을 대기 큐에 집어넣는 역할만 함`
- `그래서 클라이언트에 서비스를 제공하기 위해 또 다른 소켓이 필요`

→ 추가적인 소켓이 만들어지는 과정은 accept 함수의 호출에서 이루어짐

### 5-3. 클라이언트의 연결요청 수락

```c
#include <sys/sock.h>

int accept(int sock, struct sockaddr * addr, socklen_t * addrlen);
// 성공 시 생성된 소켓의 파일 디스크립터, 실패 시 -1 반환
```

| sock | 서버 소켓의 파일 디스크립터 전달 |
| --- | --- |
| addr | 연결요청 한 클라이언트의 주소정보를 담을 변수의 주소 값 전달, 함수 호출이 완료되면 인자로 전달된 주소의 변수에는 클라이언트의 주소정보가 채워진다 |
| addrlen | 두 번째 매개변수 addr에 전달된 주소의 변수 크기를 바이트 단위로 전달, 단 크기정보를 변수에 저장한 다음에 변수의 주소 값을 전달한다. 그리고 함수호출이 완료되면 크기정보로 채워져 있던 변수에는 클라이언트의 주소정보 길이가 바이트 단위로 계산되어 채워진다 |

<img width="534" alt="7" src="https://github.com/user-attachments/assets/d67cfa6f-6226-4b43-9bcf-034d310fcaef">

- 연결요청 정보를 참조하여 클라이언트 소켓과의 통신을 위한 별도의 소켓을 추가로 하나 더 생성함
- 그리고 이렇게 생성된 소켓을 대상으로 데이터의 송수신이 진행된다
- 실제로 서버의 코드를 보면 소켓이 추가로 생성되는 것을 확인할 수 있음

Q1. accept 함수는 서버소켓 디스크립터를 왜 받아올까?

- 연결요청 대기 큐와 서버소켓은 짝꿍임
- 서버 소켓이 여러 개 일 수 있음
- 구분을 위해 입력받음

Q2. accept함수에 의해 생성된 새로운 소켓은 port가 몇 번일까?

- `서버소켓이랑 같은 port를 가짐.`
- 프로그래머는 중복된 port를 못만드는데, 운영체제는 만들 수 있음
- 그래서 같은 port로 매핑가능

Q3. 하나의 서버소켓에 여러 개의 클라이언트 연결 요청이 들어왔다?

- 각 클라이언트마다 새로운 소켓을 매핑한다
- 이때 새로운 소켓들은 모두 서버소켓과 동일한 port번호를 가진다
- 그럼 어떤 클라이언트와 연결된 소켓인지 어떻게 구분할까?
- 클라이언트의 주소정보를 갖고 있어서, 이 정보를 통해 같은 port라도 클라이언트들을 구분한다

---

## 6. TCP 클라이언트

### 6-1. TCP 클라이언트의 기본적인 함수 호출 순서

```c
#include <sys/socket.h>

int connect(int sock, const struct sockaddr * servaddr, socklen_t addrlen);
// 성공 시 생성된 소켓의 파일 디스크립터, 실패 시 -1 반환
```

| `sock` | 클라이언트 소켓의 파일 디스크립터 전달 |
| --- | --- |
| `servaddr` | 연결 요청 한 클라이언트의 주소정보를 담을 변수의 주소 값 전달, 함수호출이 완료되면 인자로 전달된 주소의 변수에는 클라이언트의 주소 정보가 채워진다 |
| `addrlen` | 두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달, 단 크기정보를 변수에 저장한 다음 변수의 주소 값을 전달한다. 그리고 함수호출이 완료되면 크기 정보로 채워져 있던 변수에는 클라이언트의 주소 정보 길이가 바이트 단위로 계산되어 채워진다. |

<img width="380" alt="8" src="https://github.com/user-attachments/assets/881bc73a-8fe0-47f9-8744-02bb51cafa40">

- 클라이언트의 경우 소켓을 생성하고, 이 소켓을 대상으로 연결의 요청을 위해서 connect 함수를 호출하는 것이 전부이다
- connect 함수를 호출할 때 연결할 `서버의 주소 정보`도 함께 전달한다

### 6-2. TCP 기반 서버, 클라이언트의 함수 호출 관계

<img width="599" alt="9" src="https://github.com/user-attachments/assets/031e21a2-3e84-4673-9776-aa5b4b069177">

- 서버는 connect()가 언제 들어올지 알 수 없어서, 그냥 listen() 호출하고 바로 accept() 호출 함
- 확인할 사항은, 서버의 listen 함수 호출 이후에야 클라이언트의 connect 함수 호출이 유효하다는 점

---

## 7. Iterative 기반의 서버, 클라이언트 구현

- 다수의 클라이언트로부터 서비스를 제공할 수 있는 서버를 만들어보자

### Iterative 서버의 구현

<img width="271" alt="10" src="https://github.com/user-attachments/assets/b1a4a492-16d3-412b-a368-f8a2bc9cf77b">

- `위 그림처럼 반복적으로 accept 함수를 호출하면, 계속해서 클라이언트의 연결 요청을 수락할 수 있다`
- 그러나, 동시에 둘 이상의 클라이언트에게 서비스를 제공할 수 있는 모델은 아니다
- 줄 서서 기다리는 모델임
- listen()에서 서버 소켓이 생성되고, 5개의 연결 요청 큐에 클라이언트 정보가 저장되어 있다
- 하나의 연결 요청을 처리하고 나면, 다음 클라리언트 꺼를 처리하는 모델이다

<img width="955" alt="11" src="https://github.com/user-attachments/assets/12734564-c1c9-4dc7-a2ef-a3f2ba165dea">

- 이렇게 하면 5번의 클라이언트 요청을 처리할 수 있다
- 이후 서버 소켓은 종료된다

### 에코 클라이언트의 문제점(앞에서 본 코드)

<img width="699" alt="12" src="https://github.com/user-attachments/assets/8dcf3b52-478a-48e7-96df-4f1f0325c0b7">

- 제대로 동작은 하나 문제 발생 소지가 있는 TCP 에코 클라이언트 코드
- TCP의 데이터 송수신에는 경계가 존재하지 않는다. 그런데 위 코드는 다음의 사항을 가정한다
- “한 번의 read 함수 호출로 앞서 전송된 문자열 전체를 읽어 들일 수 있다”
- 그러나 이는 잘못된 가정이다. TCP에는 데이터의 경계가 존재하지 않기 때문에 서버가 전송한 문자열의 일부만 읽혀질 수도 있다
- str_len을 누적해서 10바이트인지 검사해야 함→그때까지 반복해줘야 함

---

## 윈도우 기반으로 구현하기

### 윈도우 기반으로 변경할 때 필요한 것(like 공식)

1. WSAStartup, WSACleanup 함수 호출을 통한 소켓 라이브러리의 초기화와 해제
2. 자료형과 변수의 이름을 윈도우 스타일로 변경하기
3. 데이터 송수신을 위해서 read, write 함수 대신 recv, send 함수 호출하기
4. 소켓의 종료를 위해서 close 대신 closesocket 함수 호출하기
